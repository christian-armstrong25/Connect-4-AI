// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Connect4$Game = require("./Connect4.bs.js");

function AIPlayer(MyGame) {
  var minimax = function (state, depth) {
    if (depth === 0) {
      return Curry._1(MyGame.estimateValue, state);
    }
    var match = Curry._1(MyGame.gameStatus, state);
    if (typeof match === "number") {
      return Curry._1(MyGame.estimateValue, state);
    }
    if (match.TAG === /* Win */0) {
      return Curry._1(MyGame.estimateValue, state);
    }
    if (match._0) {
      var ns = Curry._2(MyGame.nextState, state, argMin(state, depth, minimax));
      return Curry._1(MyGame.estimateValue, ns) + minimax(ns, depth - 1 | 0);
    }
    var ns$1 = Curry._2(MyGame.nextState, state, argMax(state, depth, minimax));
    return Curry._1(MyGame.estimateValue, ns$1) + minimax(ns$1, depth - 1 | 0);
  };
  var argMaxHelper = function (state, _moveList, _best, depth, funct) {
    while(true) {
      var best = _best;
      var moveList = _moveList;
      if (!moveList) {
        return best;
      }
      var tl = moveList.tl;
      var hd = moveList.hd;
      if (tl) {
        var v2 = best[0];
        var v1 = Curry._2(funct, Curry._2(MyGame.nextState, state, hd), depth);
        var newBest = v1 > v2 ? [
            v1,
            hd
          ] : [
            v2,
            best[1]
          ];
        _best = newBest;
        _moveList = tl;
        continue ;
      }
      var v2$1 = best[0];
      var v1$1 = Curry._2(funct, Curry._2(MyGame.nextState, state, hd), depth);
      if (v1$1 > v2$1) {
        return [
                v1$1,
                hd
              ];
      } else {
        return [
                v2$1,
                best[1]
              ];
      }
    };
  };
  var argMax = function (state, depth, funct) {
    var match = Curry._1(MyGame.legalMoves, state);
    if (!match) {
      return Pervasives.failwith("no legal moves");
    }
    var tl = match.tl;
    var hd = match.hd;
    if (tl) {
      return argMaxHelper(state, tl, [
                    Curry._2(funct, Curry._2(MyGame.nextState, state, hd), depth - 1 | 0),
                    hd
                  ], depth - 1 | 0, funct)[1];
    } else {
      return hd;
    }
  };
  var argMin = function (state, depth, funct) {
    var fneg = function (x, y) {
      return -Curry._2(funct, x, y);
    };
    return argMax(state, depth, fneg);
  };
  var nextMove = function (state) {
    var match = Curry._1(MyGame.gameStatus, state);
    if (typeof match === "number" || match.TAG === /* Win */0) {
      return Pervasives.failwith("game over");
    } else if (match._0) {
      return argMin(state, 3, minimax);
    } else {
      return argMax(state, 3, minimax);
    }
  };
  return {
          PlayerGame: MyGame,
          minimax: minimax,
          argMaxHelper: argMaxHelper,
          argMax: argMax,
          argMin: argMin,
          depth: 3,
          nextMove: nextMove,
          playerName: "Tran"
        };
}

var MyGame_stringOfPlayer = Connect4$Game.Connect4.stringOfPlayer;

var MyGame_stringOfState = Connect4$Game.Connect4.stringOfState;

var MyGame_stringOfMove = Connect4$Game.Connect4.stringOfMove;

var MyGame_initialState = Connect4$Game.Connect4.initialState;

var MyGame_legalMoves = Connect4$Game.Connect4.legalMoves;

var MyGame_gameStatus = Connect4$Game.Connect4.gameStatus;

var MyGame_nextState = Connect4$Game.Connect4.nextState;

var MyGame_moveOfString = Connect4$Game.Connect4.moveOfString;

var MyGame_estimateValue = Connect4$Game.Connect4.estimateValue;

var MyGame = {
  stringOfPlayer: MyGame_stringOfPlayer,
  stringOfState: MyGame_stringOfState,
  stringOfMove: MyGame_stringOfMove,
  initialState: MyGame_initialState,
  legalMoves: MyGame_legalMoves,
  gameStatus: MyGame_gameStatus,
  nextState: MyGame_nextState,
  moveOfString: MyGame_moveOfString,
  estimateValue: MyGame_estimateValue
};

function minimax(state, depth) {
  if (depth === 0) {
    return Curry._1(Connect4$Game.Connect4.estimateValue, state);
  }
  var match = Curry._1(Connect4$Game.Connect4.gameStatus, state);
  if (typeof match === "number") {
    return Curry._1(Connect4$Game.Connect4.estimateValue, state);
  }
  if (match.TAG === /* Win */0) {
    return Curry._1(Connect4$Game.Connect4.estimateValue, state);
  }
  if (match._0) {
    var ns = Curry._2(Connect4$Game.Connect4.nextState, state, argMin(state, depth, minimax));
    return Curry._1(Connect4$Game.Connect4.estimateValue, ns) + minimax(ns, depth - 1 | 0);
  }
  var ns$1 = Curry._2(Connect4$Game.Connect4.nextState, state, argMax(state, depth, minimax));
  return Curry._1(Connect4$Game.Connect4.estimateValue, ns$1) + minimax(ns$1, depth - 1 | 0);
}

function argMaxHelper(state, _moveList, _best, depth, funct) {
  while(true) {
    var best = _best;
    var moveList = _moveList;
    if (!moveList) {
      return best;
    }
    var tl = moveList.tl;
    var hd = moveList.hd;
    if (tl) {
      var v2 = best[0];
      var v1 = Curry._2(funct, Curry._2(Connect4$Game.Connect4.nextState, state, hd), depth);
      var newBest = v1 > v2 ? [
          v1,
          hd
        ] : [
          v2,
          best[1]
        ];
      _best = newBest;
      _moveList = tl;
      continue ;
    }
    var v2$1 = best[0];
    var v1$1 = Curry._2(funct, Curry._2(Connect4$Game.Connect4.nextState, state, hd), depth);
    if (v1$1 > v2$1) {
      return [
              v1$1,
              hd
            ];
    } else {
      return [
              v2$1,
              best[1]
            ];
    }
  };
}

function argMax(state, depth, funct) {
  var match = Curry._1(Connect4$Game.Connect4.legalMoves, state);
  if (!match) {
    return Pervasives.failwith("no legal moves");
  }
  var tl = match.tl;
  var hd = match.hd;
  if (tl) {
    return argMaxHelper(state, tl, [
                  Curry._2(funct, Curry._2(Connect4$Game.Connect4.nextState, state, hd), depth - 1 | 0),
                  hd
                ], depth - 1 | 0, funct)[1];
  } else {
    return hd;
  }
}

function argMin(state, depth, funct) {
  var fneg = function (x, y) {
    return -Curry._2(funct, x, y);
  };
  return argMax(state, depth, fneg);
}

function nextMove(state) {
  var match = Curry._1(Connect4$Game.Connect4.gameStatus, state);
  if (typeof match === "number" || match.TAG === /* Win */0) {
    return Pervasives.failwith("game over");
  } else if (match._0) {
    return argMin(state, 3, minimax);
  } else {
    return argMax(state, 3, minimax);
  }
}

var playerName = "Tran";

var TestAIPlayer = {
  PlayerGame: MyGame,
  minimax: minimax,
  argMaxHelper: argMaxHelper,
  argMax: argMax,
  argMin: argMin,
  depth: 3,
  nextMove: nextMove,
  playerName: playerName
};

var TestGame;

var MyAIPlayer = {
  PlayerGame: MyGame,
  nextMove: nextMove,
  playerName: playerName
};

exports.AIPlayer = AIPlayer;
exports.TestGame = TestGame;
exports.TestAIPlayer = TestAIPlayer;
exports.MyAIPlayer = MyAIPlayer;
/* Connect4-Game Not a pure module */
